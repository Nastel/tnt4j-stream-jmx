{
  "name": "Stream-JMX",
  "tagline": "A Lightweight framework to stream & monitor JMX metrics",
  "body": "# Stream-JMX\r\nA Lightweight framework to stream and monitor JMX metrics.\r\n(Formerly known as PingJMX)\r\n\r\nStream JMX metrics to: \r\n* Central monitoring server\r\n* File, socket, log4j\r\n* User defined destination\r\n\r\nThese metrics can be used to monitor health, performance and availability of your JVMs and applications.\r\nUse Stream-JMX to embed a monitoring agent within your application and monitor memory, GC activity, CPU as\r\nwell as user defined MBeans.\r\n\r\nHere is what you can do with Stream-JMX:\r\n* Periodic JVM heartbeat\r\n* Monitor memory utilization, GC activity, memory leaks\r\n* High/Low, normal vs. abnormal CPU usage\r\n* Monitor threading, runtime and other JVM performance metrics\r\n* Monitor standard and custom MBean attributes\r\n* Conditional actions based on MBean attribute values\r\n* Conditional streaming based on custom filters\r\n* Application state dumps on VM shut-down for diagnostics\r\n\r\n# Why Stream-JMX\r\nStream-JMX provides and easy, lightweight and secure way to stream and monitor JMX metrics from within\r\njava runtime containers.\r\n\r\n* Stream JMX metrics out of the JVM container (vs. polling from outside/remote)\r\n* Makes it easy to monitor farms of JMVs, application servers\r\n* Reduce cyber security risk: No need to enable remote JMX, SSL, security, ports, firewalls\r\n* Integration with monitoring tools for alerting, pro-active monitoring (AutoPilot M6)\r\n* Integration with cloud analytics tools (https://www.jkoolcloud.com via JESL)\r\n* Integration with log4j, slf4j, jkoocloud (via TNT4J event sinks)\r\n* Embedded application state dump framework for diagnostics\r\n* Easily build your own extensions, monitors\r\n\r\n<b>NOTE:</b> JESL provides a way to stream events generated by Stream-JMX to jKool Cloud. \r\nFor more information on JESL visit: http://nastel.github.io/JESL/\r\n\r\n# Using Stream-JMX\r\nIt is simple: (1) run Stream-JMX as a `-javaagent` or (2) imbed Stream-JMX code into your application.\r\n\r\nRunning Stream-JMX as javaagent:\r\n```java\r\njava -javaagent:tnt4j-stream-jmx.jar=\"*:*!30000\" -Dtnt4j.config=tnt4j.properties -classpath \"tnt4j-stream-jmx.jar;lib/tnt4j-api-final-all.jar\" your.class.name your-args\r\n```\r\nImbed Stream-JMX code into your application:\r\n```java\r\n// obtain SamplerFactory instance\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// create an instance of the sampler that will sample mbeans\r\nSampler sampler = factory.newInstance();\r\n// schedule collection (ping) for given MBean filter and 30000 ms sampling period\r\nsampler.setSchedule(Sampler.JMX_FILTER_ALL, 30000).run();\r\n```\r\n<b>NOTE:</b> `setSchedule(..).run()` sequence must be called to run the schedule. `setSchedule(..)` just sets the\r\nscheduling parameters, `run()` executes the schedule.\r\n\r\nTo schedule metric collection for a specific MBean server:\r\n```java\r\n// obtain SamplerFactory instance\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// create an instance of the sampler that will sample mbeans\r\nSampler sampler = factory.newInstance(ManagementFactory.getPlatformMBeanServer());\r\n// schedule collection (ping) for given MBean filter and 30000 ms sampling period\r\nsampler.setSchedule(Sampler.JMX_FILTER_ALL, 30000).run();\r\n```\r\nStream-JMX supports inclusion and exclusion filters.\r\nTo schedule metric collection for a specific MBean server and exclude certain MBeans:\r\n(Exclusion filters are applied after inclusion filters)\r\n```java\r\n// obtain SamplerFactory instance\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// create an instance of the sampler that will sample mbeans\r\nSampler sampler = factory.newInstance(ManagementFactory.getPlatformMBeanServer());\r\nString excludeMBeanFilter = \"mydomain:*\";\r\n// schedule collection (ping) for given MBean filter and 30000 ms sampling period\r\nsampler.setSchedule(Sampler.JMX_FILTER_ALL, excludeMBeanFilter, 30000).run();\r\n```\r\nBelow is an example of how to sample all registered mbean servers:\r\n```java\r\n// obtain SamplerFactory instance\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// find other registered mbean servers\r\nArrayList<MBeanServer> mlist = MBeanServerFactory.findMBeanServer(null);\r\nfor (MBeanServer server: mlist) {\r\n\tSampler jmxp = factory.newInstance(server);\r\n\tjmxp.setSchedule(Sampler.JMX_FILTER_ALL, 30000).run();\r\n}\r\n```\r\nAlternatively, Stream-JMX provides a helper class `SamplingAgent` that lets you schedule sampling for all registered `MBeanServer` instances.\r\n```java\r\nSamplingAgent.sample(Sampler.JMX_FILTER_ALL, Sampler.JMX_FILTER_NONE, 60000, TimeUnit.MILLISECONDS);\r\n```\r\n<b>NOTE:</b> Sampled MBean attributes and associated values are stored in a collection of `Snapshot` objects stored within `Activity` instance. Current `Activity` instance can be obtained via `AttributeSample` passed when calling listeners such as `AttributeCondition`, `SampleListener`. Snapshots can be accessed using `Activity.getSnapshots()` method call.\r\n\r\n<b>NOTE:</b> Sampled output is written to underlying tnt4j event sink configured in `tnt4j.properties` file. Sink destinations could be a file, socket, log4j, user defined event sink implementations. \r\n\r\nFor more information on TNT4J and `tnt4j.properties` see (https://github.com/Nastel/TNT4J/wiki/Getting-Started).\r\n\r\n## Running Stream-JMX as standalone app\r\nExample below runs `SamplingAgent` helper class as a standalone java application with a given MBean filter `\"*:*\"`, sampling period in milliseconds (`10000`), and time to run in milliseconds (`60000`):\r\n```java\r\njava -Dorg.tnt4j.stream.jmx.agent.trace=true -classpath \"tnt4j-stream-jmx.jar;lib/tnt4j-api-final-all.jar\" org.tnt4j.stream.jmx.SamplingAgent \"*:*\" none 10000 60000\r\n```\r\n\r\n## Running Stream-JMX as -javaagent\r\nStream-JMX can be invoked as `-javaagent` without changing your application code:\r\n```java\r\njava -javaagent:tnt4j-stream-jmx.jar=\"*:*!30000\" -Dtnt4j.config=tnt4j.properties -classpath \"tnt4j-stream-jmx.jar;lib/tnt4j-api-final-all.jar\" your.class.name your-args\r\n```\r\nThe options are `-javaagent:tnt4j-stream-jmx.jar=\"mbean-filter!sample-time-ms\"`, classpath must include pingjmx jar files as well as locations of log4j and tnt4j configuration files.\r\n\r\n## Where do the streams go?\r\nStream-JMX streams all collected metrics based on a scheduled interval via TNT4J event streaming framework.\r\nAll streams are written into TNT4J event sinks defined in `tnt4j.properties` file which is defined by `-Dtnt4j.config=tnt4j.properties` property. \r\n\r\nTo stream Stream-JMX to jkool cloud (https://www.jkoolcloud.com): (Requires JESL libraries (see https://github.com/Nastel/JESL))\r\n```\r\n;Stanza used for Stream-JMX sources\r\n{\r\n\tsource: org.tnt4j.stream.jmx\r\n\tsource.factory: com.nastel.jkool.tnt4j.source.SourceFactoryImpl\r\n\tsource.factory.GEOADDR: New York\r\n\tsource.factory.DATACENTER: YourDC\r\n\tsource.factory.RootFQN: SERVER=?#DATACENTER=?#GEOADDR=?\t\r\n\tsource.factory.RootSSN: tnt4j-stream-jmx\t\r\n\t\r\n\ttracker.factory: com.nastel.jkool.tnt4j.tracker.DefaultTrackerFactory\r\n\tdump.sink.factory: com.nastel.jkool.tnt4j.dump.DefaultDumpSinkFactory\r\n\r\n\t; Event sink definition where all streams are recorded\r\n\tevent.sink.factory: com.nastel.jkool.tnt4j.sink.BufferedEventSinkFactory\r\n\r\n\t; Event Sink configuration for streaming to jKool Cloud\r\n\t; event.sink.factory.EventSinkFactory.Filename: jkoocloud.json\r\n\tevent.sink.factory.EventSinkFactory.Url: https://data.jkoolcloud.com:6585\r\n\tevent.sink.factory.EventSinkFactory.Token: ACCESS-TOKEN\r\n\tevent.formatter: com.nastel.jkool.tnt4j.format.JSONFormatter\r\n\r\n\t; Configure default sink filter \r\n\tevent.sink.factory.Filter: com.nastel.jkool.tnt4j.filters.EventLevelTimeFilter\r\n\tevent.sink.factory.Filter.Level: TRACE\r\n\t\r\n\ttracking.selector: com.nastel.jkool.tnt4j.selector.DefaultTrackingSelector\r\n\ttracking.selector.Repository: com.nastel.jkool.tnt4j.repository.FileTokenRepository\r\n}\r\n```\r\nBelow is an example of TNT4J stream definition where all Stream-JMX streams are written into a socket event sink\r\n`com.nastel.jkool.tnt4j.sink.SocketEventSinkFactory`, formatted by `org.tnt4j.stream.jmx.format.FactNameValueFormatter` :\r\n```\r\n;Stanza used for Stream-JMX sources\r\n{\r\n\tsource: org.tnt4j.stream.jmx\r\n\tsource.factory: com.nastel.jkool.tnt4j.source.SourceFactoryImpl\r\n\tsource.factory.GEOADDR: New York\r\n\tsource.factory.DATACENTER: YourDC\r\n\tsource.factory.RootFQN: SERVER=?#DATACENTER=?#GEOADDR=?\t\r\n\tsource.factory.RootSSN: tnt4j-stream-jmx\t\r\n\t\r\n\ttracker.factory: com.nastel.jkool.tnt4j.tracker.DefaultTrackerFactory\r\n\tdump.sink.factory: com.nastel.jkool.tnt4j.dump.DefaultDumpSinkFactory\r\n\r\n\t; Event sink definition where all streams are recorded\r\n\r\n\tevent.sink.factory: com.nastel.jkool.tnt4j.sink.BufferedEventSinkFactory\r\n\tevent.sink.factory.EventSinkFactory: com.nastel.jkool.tnt4j.sink.SocketEventSinkFactory\r\n\tevent.sink.factory.EventSinkFactory.eventSinkFactory: com.nastel.jkool.tnt4j.sink.NullEventSinkFactory\r\n\tevent.sink.factory.EventSinkFactory.Host: localhost\r\n\tevent.sink.factory.EventSinkFactory.Port: 6060\r\n\r\n\t; Configure default sink filter \r\n\tevent.sink.factory.Filter: com.nastel.jkool.tnt4j.filters.EventLevelTimeFilter\r\n\tevent.sink.factory.Filter.Level: TRACE\r\n\t\r\n\tevent.formatter: org.tnt4j.stream.jmx.format.FactNameValueFormatter\r\n\ttracking.selector: com.nastel.jkool.tnt4j.selector.DefaultTrackingSelector\r\n\ttracking.selector.Repository: com.nastel.jkool.tnt4j.repository.FileTokenRepository\r\n}\r\n```\r\nTo stream Stream-JMX into a log file `MyStream.log`:\r\n```\r\n;Stanza used for Stream-JMX sources\r\n{\r\n\tsource: org.tnt4j.stream.jmx\r\n\tsource.factory: com.nastel.jkool.tnt4j.source.SourceFactoryImpl\r\n\tsource.factory.GEOADDR: New York\r\n\tsource.factory.DATACENTER: YourDC\r\n\tsource.factory.RootFQN: SERVER=?#DATACENTER=?#GEOADDR=?\t\r\n\tsource.factory.RootSSN: tnt4j-stream-jmx\t\r\n\t\r\n\ttracker.factory: com.nastel.jkool.tnt4j.tracker.DefaultTrackerFactory\r\n\tdump.sink.factory: com.nastel.jkool.tnt4j.dump.DefaultDumpSinkFactory\r\n\r\n\t; Event sink definition where all streams are recorded\r\n\tevent.sink.factory: com.nastel.jkool.tnt4j.sink.BufferedEventSinkFactory\r\n\tevent.sink.factory.EventSinkFactory: com.nastel.jkool.tnt4j.sink.FileEventSinkFactory\r\n\tevent.sink.factory.EventSinkFactory.FileName: MyStream.log\r\n\r\n\t; Configure default sink filter \r\n\tevent.sink.factory.Filter: com.nastel.jkool.tnt4j.filters.EventLevelTimeFilter\r\n\tevent.sink.factory.Filter.Level: TRACE\r\n\t\r\n\tevent.formatter: org.tnt4j.stream.jmx.format.FactNameValueFormatter\r\n\ttracking.selector: com.nastel.jkool.tnt4j.selector.DefaultTrackingSelector\r\n\ttracking.selector.Repository: com.nastel.jkool.tnt4j.repository.FileTokenRepository\r\n}\r\n```\r\nYou can write your own custom event sinks (HTTPS, HTTP, etc) and your own stream formatters without having to change Stream-JMX code or your application. TNT4J comes with a set of built-in event sink implementations such as: \r\n\r\n* `com.nastel.jkool.tnt4j.logger.Log4JEventSinkFactory` -- log4j\r\n* `com.nastel.jkool.tnt4j.sink.BufferedEventSinkFactory` -- buffered sink\r\n* `com.nastel.jkool.tnt4j.sink.FileEventSinkFactory` - standard log file\r\n* `com.nastel.jkool.tnt4j.sink.SocketEventSinkFactory` -- socket (tcp/ip)\r\n* `com.nastel.jkool.tnt4j.sink.NullEventSinkFactory` -- null (empty)\r\n\r\n## Auto-generating application state dump\r\nStream-JMX is utilizing TNT4J state dump capability to generate application state dumps\r\n\r\n(1) Dump on VM shut-down:\r\n```java\r\njava -Dtnt4j.dump.on.vm.shutdown=true -Dtnt4j.dump.provider.default=true -Dtnt4j.dump.folder=./ ...\r\n```\r\n(2) Dump on uncaught thread exceptions:\r\n```java\r\njava -Dtnt4j.dump.on.exceptionn=true -Dtnt4j.dump.provider.default=true -Dtnt4j.dump.folder=./ ...\r\n```\r\n`-Dtnt4j.dump.folder=./` specifies the destination folder where dump (.dump) files will be created (default is current working directory).\r\n\r\nBy default Stream-JMX will generate dumps with the following info:\r\n\r\n* Java Properties Dump -- `PropertiesDumpProvider`\r\n* Java Runtime Dump -- `MXBeanDumpProvider`\r\n* Thread Stack Dump -- `ThreadDumpProvider`\r\n* Thread Deadlock Dump -- `ThreadDumpProvider`\r\n* Logging Statistics Dump -- `LoggerDumpProvider`\r\n\r\nYou may create your own dump providers and handlers (https://github.com/Nastel/TNT4J/wiki/Getting-Started#application-state-dumps)\r\n## Overriding default `SamplerFactory`\r\n`SamplerFactory` instances are used to generate `Sampler` implementation for a specific runtime environment. Stream-JMX supplies sampler and ping factories for standard JVMs, JBoss,\r\nWebSphere Application Server. You may want to override default `SamplerFactory` with your own or an altenative by specifying:\r\n```java\r\njava -Dorg.tnt4j.stream.jmx.factory=org.tnt4j.stream.jmx.PlatformSamplerFactory ...\r\n```\r\n`SamplerFactory` is used to generate instances of the underlying sampler implementatons (objects that provide sampling of underlying mbeans).\r\n```java\r\n// return default or user defined SamplerFactory implementation\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n...\r\n```\r\n## Managing Sample Behavior\r\nStream-JMX provides a way to intercept sampling events such as pre, during an post for each sample run and control sample behavior. See `SampleListener` interface for more details. Applications may register more than one listener per `Sampler`. Each listener is called in registration order.\r\n\r\nIn addition to intercepting sample events, applications may want to control how one ore more attributes are sampled and whether each sample is reported/logged. See example below:\r\n```java\r\n// return default or user defined SamplerFactory implementation\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// create an instance of the sampler that will sample mbeans\r\nSampler sampler = factory.newInstance();\r\nsampler.setSchedule(Sampler.JMX_FILTER_ALL, 30000).addListener(new MySampleListener())).run();\r\n```\r\nBelow is a sample of what `MySampleListener` may look like:\r\n```java\r\nclass MySampleListener implements SampleListener {\r\n\t@Override\r\n    public void getStats(SampleContext context, Map<String, Object> stats) {\r\n\t\t// add your own stats to the map\r\n\t}\r\n\t\r\n\t@Override\r\n    public void register(SampleContext context, ObjectName oname) {\r\n\t\tSystem.out.println(\"Register mbean: \" + oname + \", mbean.server=\" + context.getMBeanServer());\r\n\t}\r\n\r\n\t@Override\r\n    public void unregister(SampleContext context, ObjectName oname) {\r\n\t\tSystem.out.println(\"Unregister mbean: \" + oname + \", mbean.server=\" + context.getMBeanServer());\r\n    }\r\n\r\n\t@Override\r\n\tpublic void pre(SampleContext context, Activity activity) {\r\n\t\t// called once per sample, beginning of each sample\r\n\t\t// set activity to NOOP to disable further sampling\r\n\t\t// no other attribute will be sampled during current sample\r\n\t\tif (some-condition) {\r\n\t\t\tactivity.setType(OpType.NOOP);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void pre(SampleContext context, AttributeSample sample) {\r\n\t\t// called once before attribute is sampled\r\n\t\t// set exclude to true to skip sampling this attribute\r\n\t\tsample.excludeNext(sample.getAttributeInfo().isReadable());\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void post(SampleContext context, AttributeSample sample) {\r\n\t\t// called once after attribute is sampled\r\n\t\tObject value = sample.get();\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void post(SampleContext context, Activity activity) {\r\n\t\t// called once per sample, end of each sample\r\n\t\t// set activity to NOOP to disable sampling reporting\r\n\t\tif (some-condition) {\r\n\t\t\tactivity.setType(OpType.NOOP);\r\n\t\t}\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void error(SampleContext context, Throwable ex) {\r\n\t\t// called once for every exception that occurs not associated with a sample\r\n\t\tex.printStackTrace();\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void error(SampleContext context, AttributeSample sample) {\r\n\t\t// called once for every exception that occurs during each sample\r\n\t\tThrowable ex = sample.getError();\r\n\t\tex.printStackTrace();\r\n\t}\t\r\n}\r\n```\r\n## Conditions and Actions\r\nStream-JMX allows you to associate conditions with user defined actions based on values of MBean attributes on each sampling\r\ninterval. For example, what if you wanted to setup an action when a specific MBean attribute exceeds a certain threshold?\r\n\r\nStream-JMX `AttributeCondition` and `AttributeAction` interfaces allow you to call your action at runtime every time a condition is evaluated to true. See example below:\r\n```java\r\n// return default or user defined SamplerFactory implementation\r\nSamplerFactory factory = DefaultSamplerFactory.getInstance();\r\n// create an instance of the sampler that will sample mbeans\r\nSampler sampler = factory.newInstance();\r\n// create a condition when ThreadCount > 100\r\nAttributeCondition myCondition = new SimpleCondition(\"java.lang:type=Threading\", \"ThreadCount\", 100, \">\");\r\n// schedule collection (ping) for given MBean filter and 30000 ms sampling period\r\nsampler.setSchedule(Sampler.JMX_FILTER_ALL, 30000).register(myCondition, new MyAttributeAction()).run();\r\n```\r\nBelow is a sample of what `MyAttributeAction` may look like:\r\n```java\r\npublic class MyAttributeAction implements AttributeAction {\r\n\t@Override\r\n\tpublic Object action(SampleContext context, AttributeCondition cond, AttributeSample sample) {\r\n\t\tActivity activity = sample.getActivity();\r\n\t\t// obtain a collection of all sampled metrics\r\n\t\tCollection<Snapshot> metrics = activity.getSnapshots();\r\n\t\tSystem.out.println(\"Myaction called with value=\" + sample.get()\r\n\t\t\t+ \", age.usec=\" + sample.ageUsec()\r\n\t\t\t+ \", count=\" + metrics.size());\r\n\t\treturn null;\r\n\t}\r\n}\r\n```\r\n\r\n# Project Dependencies\r\nStream-JMX requires the following:\r\n* JDK 1.6+\r\n* TNT4J (https://github.com/Nastel/TNT4J)\r\n\r\n# Related Projects\r\n* TrackingFilter (http://nastel.github.io/TrackingFilter/)\r\n* JESL (http://nastel.github.io/JESL/)\r\n\r\n# Available Integrations\r\n* TNT4J (https://github.com/Nastel/TNT4J)\r\n* jkoolcloud.com (https://www.jkoolcloud.com)\r\n* AutoPilot M6 (http://www.nastel.com/products/autopilot-m6.html)\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}